<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CPC 1908 Trainer — Interactive Mini-Games (India)</title>
<style>
  :root{
    --bg:#0e1116; --card:#161b22; --ink:#e6edf3; --muted:#9fb0c3;
    --ok:#20c997; --bad:#ff6b6b; --warn:#ffd43b; --accent:#69db7c; --accent2:#4dabf7;
  }
  html,body{height:100%}
  body{
    margin:0; font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
    background: radial-gradient(1000px 600px at 20% -10%, #1b2230 0%, #0e1116 60%) fixed;
    color:var(--ink); display:flex; align-items:stretch; justify-content:center;
  }
  .wrap{width: min(1100px, 96vw); padding:20px 16px 60px}
  header{display:flex; gap:14px; align-items:center; flex-wrap:wrap; margin-bottom:10px}
  h1{font-size:clamp(20px, 3.3vw, 34px); margin:0; letter-spacing:.3px}
  .pill{
    border:1px solid #2a3444; padding:8px 12px; border-radius:999px; color:var(--muted);
    display:flex; gap:10px; align-items:center; background:rgba(255,255,255,.02)
  }
  .stat{display:flex; gap:6px; align-items:center}
  .dot{width:8px; height:8px; border-radius:50%}
  .ok{background:var(--ok)} .bad{background:var(--bad)} .acc{background:var(--accent2)}
  .toprow{display:flex; gap:10px; flex-wrap:wrap}
  .card{
    background:linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.01));
    border:1px solid #233044; border-radius:16px; padding:14px; box-shadow:0 10px 30px rgba(0,0,0,.25)
  }
  .about{margin:10px 0 18px; color:var(--muted); line-height:1.45}
  .tabs{display:flex; gap:10px; flex-wrap:wrap; margin:14px 0}
  .tab{
    border:1px solid #2b3950; padding:10px 14px; border-radius:12px; cursor:pointer;
    background:#141a23; color:var(--ink); user-select:none; transition:transform .05s ease
  }
  .tab.active{outline:2px solid var(--accent2); background:#101722}
  .tab:active{transform:translateY(1px)}
  .hidden{display:none}
  .toolbar{display:flex; gap:10px; flex-wrap:wrap; margin:10px 0}
  button{
    background:linear-gradient(180deg, #1e2a3c, #172131);
    border:1px solid #2c3b51; color:var(--ink); padding:10px 14px; border-radius:12px;
    cursor:pointer; transition:filter .15s ease, transform .05s
  }
  button:hover{filter:brightness(1.1)} button:active{transform:translateY(1px)}
  .primary{outline:2px solid var(--accent)}
  .warn{outline:2px solid var(--warn)}
  .game{
    margin-top:12px; display:grid; gap:14px; grid-template-columns: 1fr;
  }
  .lane, .board, .grid{
    background:#0f1520; border:1px dashed #34465f; border-radius:14px; padding:12px;
    min-height:120px
  }
  .lane-title{font-weight:600; color:var(--muted); margin:0 0 8px 0; font-size:14px}
  .chip{
    display:inline-flex; gap:8px; align-items:center; padding:10px 12px; border-radius:999px;
    background:#182132; border:1px solid #2a3b56; color:var(--ink); margin:6px; user-select:none;
    cursor:grab; transition:transform .1s ease, background .2s ease, border-color .2s ease
  }
  .chip:active{cursor:grabbing}
  .chip.small{font-size:14px; padding:8px 10px}
  .ghost{opacity:.55; filter:saturate(.7)}
  .dropzone{
    display:inline-flex; align-items:center; justify-content:center; text-align:center;
    min-width:160px; min-height:46px; border-radius:12px; border:1px dashed #3a4e6b; margin:6px;
    padding:8px 10px; color:#9fb0c3; background:rgba(255,255,255,.02)
  }
  .dropzone.active{outline:2px dashed var(--accent2); background:rgba(77,171,247,.08)}
  .dropzone.ok{background:rgba(32,201,151,.12); border-color:var(--ok)}
  .dropzone.bad{background:rgba(255,107,107,.12); border-color:var(--bad)}
  .shake{animation:shake .25s linear}
  @keyframes shake {
    0%,100%{transform:translateX(0)}
    20%{transform:translateX(-5px)}
    40%{transform:translateX(5px)}
    60%{transform:translateX(-3px)}
    80%{transform:translateX(3px)}
  }
  .progress{
    height:10px; background:#111825; border-radius:999px; border:1px solid #233044; overflow:hidden
  }
  .bar{height:100%; width:0%; background:linear-gradient(90deg,var(--accent2),#79f2c0)}
  .toast{
    position:fixed; bottom:20px; left:50%; transform:translateX(-50%);
    background:#111a28; color:var(--ink); border:1px solid #2b3950; padding:10px 14px;
    border-radius:12px; box-shadow:0 10px 30px rgba(0,0,0,.35); opacity:0; pointer-events:none
  }
  .toast.show{opacity:1; transition:opacity .15s}
  .grid{
    display:grid; grid-template-columns:repeat(auto-fit, minmax(180px,1fr)); gap:10px
  }
  .tile{
    background:#152033; border:1px solid #2a3a54; border-radius:12px; padding:10px; min-height:72px;
    display:flex; align-items:center; justify-content:center; text-align:center; cursor:grab
  }
  .target{
    background:#0f1725; border:1px dashed #35506e; border-radius:12px; min-height:72px; padding:8px;
    display:flex; align-items:center; justify-content:center; text-align:center; color:#9fb0c3
  }
  .row{display:flex; gap:10px; flex-wrap:wrap}
  .hint{color:var(--muted); font-size:14px}
  .kbd{font-weight:700; padding:2px 6px; border-radius:6px; border:1px solid #2a3950; background:#131a26}
  footer{margin-top:16px; color:var(--muted); font-size:13px}
  .badge{font-size:12px; padding:2px 8px; border:1px solid #2b3950; border-radius:999px; color:var(--muted)}
  .flex{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
</style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>🧭 CPC 1908 Trainer — Learn by Playing</h1>
    <div class="pill">
      <div class="stat"><span class="dot ok"></span><span id="score">Score 0</span></div>
      <div class="stat"><span class="dot acc"></span><span id="progressText">0% Progress</span></div>
      <div class="stat"><span class="dot bad"></span><span id="mistakes">Mistakes 0</span></div>
    </div>
  </header>

  <div class="about card">
    <b>Goal:</b> Master CPC basics via three mini-games. Drag, drop, and snap concepts in place. Immediate feedback & retries.  
    <div class="hint">Tip: Use mouse or touch. Press <span class="kbd">R</span> to reshuffle current game. Press <span class="kbd">N</span> to move to the next game.</div>
  </div>

  <div class="tabs">
    <div class="tab active" data-game="flow">1) Procedural Flow Builder</div>
    <div class="tab" data-game="juris">2) Jurisdiction & Stages Sort</div>
    <div class="tab" data-game="orders">3) Order–Rule Snap</div>
  </div>

  <div class="toolbar">
    <button id="btnReset" class="warn">Reset Current</button>
    <button id="btnNext" class="primary">Next Game ▶</button>
    <button id="btnExport">Export Results (CSV)</button>
    <button id="btnPlayAgain">Play Again (All)</button>
  </div>

  <!-- Game 1: Procedural Flow -->
  <section id="flow" class="game">
    <div class="card">
      <b>Procedural Flow Builder:</b> Drag the steps of a civil suit onto the timeline in the correct sequence (left → right).
      <div class="progress" style="margin-top:8px"><div class="bar" id="barFlow"></div></div>
    </div>
    <div class="lane card">
      <p class="lane-title">Your Timeline (drop here in order)</p>
      <div id="flowTargets" class="row"></div>
    </div>
    <div class="board card">
      <p class="lane-title">Available Steps</p>
      <div id="flowPool" class="row"></div>
    </div>
  </section>

  <!-- Game 2: Jurisdiction & Stages Sort -->
  <section id="juris" class="game hidden">
    <div class="card">
      <b>Jurisdiction & Stages Sort:</b> Drag each card to the correct column. Get instant feedback per drop.
      <div class="progress" style="margin-top:8px"><div class="bar" id="barJuris"></div></div>
    </div>
    <div class="grid">
      <div class="card">
        <p class="lane-title">Magistrate/Small Causes Court</p>
        <div id="zoneMag" class="row"></div>
      </div>
      <div class="card">
        <p class="lane-title">District Court</p>
        <div id="zoneDist" class="row"></div>
      </div>
      <div class="card">
        <p class="lane-title">High Court</p>
        <div id="zoneHigh" class="row"></div>
      </div>
      <div class="card">
        <p class="lane-title">Appellate Stage</p>
        <div id="zoneApp" class="row"></div>
      </div>
    </div>
    <div class="board card">
      <p class="lane-title">Cards to Sort</p>
      <div id="jurisPool" class="row"></div>
    </div>
  </section>

  <!-- Game 3: Order–Rule Snap -->
  <section id="orders" class="game hidden">
    <div class="card">
      <b>Order–Rule Snap:</b> Drag each <i>Order/Rule</i> tag onto its matching concept tile.
      <div class="progress" style="margin-top:8px"><div class="bar" id="barOrders"></div></div>
    </div>
    <div class="grid">
      <div class="card">
        <p class="lane-title">Concept Targets</p>
        <div id="orderTargets" class="grid"></div>
      </div>
      <div class="card">
        <p class="lane-title">Order/Rule Tags</p>
        <div id="orderPool" class="row"></div>
      </div>
    </div>
  </section>

  <footer>
    <span class="badge">CPC 1908 study aid</span>
    <span class="badge">Single player</span>
    <span class="badge">CSV export</span>
  </footer>

  <div id="toast" class="toast">Feedback</div>
</div>

<script>
/* ======= CPC DATA (simplified for learning) ======= */
const CPC_FLOW = [
  "Plaint filed (Order 7)",
  "Court scrutiny & admission",
  "Issue of summons to defendant (Order 5)",
  "Written statement / defence (Order 8)",
  "Framing of issues (Order 14)",
  "Discovery & inspection (Order 11-13)",
  "Plaintiff evidence",
  "Defendant evidence",
  "Arguments",
  "Judgment (Sec. 33)",
  "Decree (Sec. 2(2))",
  "Appeal (Sec. 96 / Order 41)",
  "Execution (Order 21)"
];

const JURIS_CARDS = [
  { text:"Small causes—minor value suits", zone:"Mag" },
  { text:"Original civil jurisdiction—higher value suits", zone:"Dist" },
  { text:"Original civil jurisdiction (select matters), writs", zone:"High" },
  { text:"First appeal (Sec. 96)", zone:"App" },
  { text:"Second appeal (Sec. 100)", zone:"App" },
  { text:"Return of plaint (Order 7 Rule 10) — based on jurisdiction", zone:"Dist" },
  { text:"Revision under Sec. 115 (HC)", zone:"High" },
  { text:"Transfer of suits (Sec. 24)", zone:"High" },
];

const ORDER_MATCH = [
  { order:"Order 5", concept:"Issue and service of summons" },
  { order:"Order 7", concept:"Plaint—particulars" },
  { order:"Order 8", concept:"Written statement, set-off & counter-claim" },
  { order:"Order 11", concept:"Discovery by interrogatories" },
  { order:"Order 13", concept:"Production, impounding & return of documents" },
  { order:"Order 14", concept:"Framing of issues" },
  { order:"Order 17", concept:"Adjournments" },
  { order:"Order 20", concept:"Judgment & decree" },
  { order:"Order 21", concept:"Execution of decrees" },
];

/* ======= STATE ======= */
let score=0, mistakes=0;
let logRows = []; // {ts, game, item, action, result, attempts}
let gameIndex = 0; // 0,1,2
const games = ["flow","juris","orders"];
const qsAttempts = new Map(); // key per item ⇒ attempts

/* ======= UTIL ======= */
const byId = id => document.getElementById(id);
const toast = (msg, tone="info")=>{
  const t=byId("toast"); t.textContent = msg;
  t.style.borderColor = tone==="ok" ? "var(--ok)" : tone==="bad" ? "var(--bad)" : "#2b3950";
  t.classList.add("show");
  setTimeout(()=>t.classList.remove("show"), 1300);
};
const shuffle = arr => arr.slice().sort(()=>Math.random()-0.5);
const nowISO = ()=> new Date().toISOString();

function updateHUD(){
  byId("score").textContent = `Score ${score}`;
  byId("mistakes").textContent = `Mistakes ${mistakes}`;
  // overall progress = matched items / total items across current game
  let total=0, done=0;
  if(currentGameId()==="flow"){ total=CPC_FLOW.length; done = document.querySelectorAll('#flowTargets .chip.locked').length; byId("barFlow").style.width = (done/total*100)+"%"; }
  if(currentGameId()==="juris"){ total=JURIS_CARDS.length; done = document.querySelectorAll('#jurisPool .tile').length===0 ? total : total - document.querySelectorAll('#jurisPool .tile').length; byId("barJuris").style.width=(done/total*100)+"%"; }
  if(currentGameId()==="orders"){ total=ORDER_MATCH.length; done = document.querySelectorAll('#orderTargets .dropzone.ok').length; byId("barOrders").style.width=(done/total*100)+"%"; }
  byId("progressText").textContent = `${Math.round(done/Math.max(total,1)*100)}% Progress`;
}
function log(game, item, action, result){
  const key = `${game}|${item}`;
  const attempts = (qsAttempts.get(key)||0);
  logRows.push({ts: nowISO(), game, item, action, result, attempts});
}

/* ======= DRAG CORE (pointer-based) ======= */
let dragEl=null, originParent=null, originIndex=0;

function makeDraggable(el){
  el.draggable = true;
  el.addEventListener('dragstart', e=>{
    dragEl = el; originParent = el.parentElement;
    originIndex = [...originParent.children].indexOf(el);
    setTimeout(()=>el.classList.add('ghost'),0);
    e.dataTransfer.setData('text/plain', el.dataset.key||el.textContent.trim());
  });
  el.addEventListener('dragend', ()=>{
    if(dragEl){ dragEl.classList.remove('ghost'); dragEl=null; }
  });
}
function allowDrop(zone){
  zone.addEventListener('dragover', e=>{
    e.preventDefault(); zone.classList.add('active');
  });
  zone.addEventListener('dragleave', ()=>zone.classList.remove('active'));
}

function snapBack(el){
  try{
    originParent.insertBefore(el, originParent.children[originIndex] || null);
  }catch{ originParent.appendChild(el); }
  el.classList.add('shake');
  setTimeout(()=>el.classList.remove('shake'),200);
}

/* ======= GAME 1: FLOW ======= */
function setupFlow(){
  const pool = byId('flowPool'); const targets = byId('flowTargets');
  pool.innerHTML=''; targets.innerHTML='';
  const steps = shuffle(CPC_FLOW);
  steps.forEach((t,i)=>{
    const chip = document.createElement('div');
    chip.className='chip'; chip.textContent=t; chip.dataset.key = `flow-${t}`;
    makeDraggable(chip); pool.appendChild(chip);
  });
  // create N empty slots; accept only next-in-sequence correctness
  CPC_FLOW.forEach((_,i)=>{
    const dz = document.createElement('div');
    dz.className='dropzone'; dz.dataset.index = i; dz.textContent = `Step ${i+1}`;
    allowDrop(dz);
    dz.addEventListener('drop', e=>{
      e.preventDefault(); dz.classList.remove('active');
      const incoming = dragEl; if(!incoming) return;
      const want = CPC_FLOW[+dz.dataset.index];
      const txt = incoming.textContent.trim();
      const key = `flow|${want}`;
      qsAttempts.set(key, (qsAttempts.get(key)||0)+1);

      if(txt === want && !dz.classList.contains('ok')){
        dz.classList.add('ok'); dz.textContent=''; incoming.classList.add('locked'); incoming.classList.remove('ghost');
        incoming.classList.add('small');
        dz.appendChild(incoming);
        score+=2; log('Flow', want, 'place', 'correct');
        toast('✅ Correct order!', 'ok');
      }else{
        mistakes++; log('Flow', want, 'place', 'wrong');
        dz.classList.add('bad'); setTimeout(()=>dz.classList.remove('bad'),300);
        toast('❌ Not the next step. Try again.', 'bad');
        snapBack(incoming);
      }
      updateHUD();
    });
    targets.appendChild(dz);
  });
  updateHUD();
}

/* ======= GAME 2: JURIS ======= */
function setupJuris(){
  const zones = { Mag: byId('zoneMag'), Dist: byId('zoneDist'), High: byId('zoneHigh'), App: byId('zoneApp') };
  Object.values(zones).forEach(z=>{ z.innerHTML=''; z.classList.remove('ok','bad'); allowDrop(z); });
  const pool = byId('jurisPool'); pool.innerHTML='';

  const cards = shuffle(JURIS_CARDS);
  cards.forEach((c,i)=>{
    const tile = document.createElement('div');
    tile.className='tile'; tile.textContent=c.text; tile.dataset.zone=c.zone; tile.dataset.key=`juris-${i}`;
    makeDraggable(tile); pool.appendChild(tile);
  });

  Object.entries(zones).forEach(([code,zone])=>{
    zone.addEventListener('drop', e=>{
      e.preventDefault(); zone.classList.remove('active');
      const incoming=dragEl; if(!incoming) return;
      const want = code;
      const txt = incoming.textContent.trim();
      const key = `juris|${txt}`;
      qsAttempts.set(key, (qsAttempts.get(key)||0)+1);

      if(incoming.dataset.zone===want){
        zone.appendChild(incoming);
        incoming.style.cursor='default';
        score+=2; log('Juris', txt, 'sort', 'correct');
        toast('✅ Correct placement', 'ok');
      }else{
        mistakes++; log('Juris', txt, 'sort', 'wrong');
        zone.classList.add('bad'); setTimeout(()=>zone.classList.remove('bad'),250);
        toast('❌ Wrong column. Try another.', 'bad');
        snapBack(incoming);
      }
      updateHUD();
    });
  });
  updateHUD();
}

/* ======= GAME 3: ORDER–RULE SNAP ======= */
function setupOrders(){
  const targets = byId('orderTargets'); const pool = byId('orderPool');
  targets.innerHTML=''; pool.innerHTML='';
  const pairs = shuffle(ORDER_MATCH);
  // Targets (concepts)
  pairs.forEach((p,i)=>{
    const dz = document.createElement('div');
    dz.className='dropzone'; dz.dataset.concept=p.concept; dz.textContent=p.concept;
    allowDrop(dz);
    dz.addEventListener('drop', e=>{
      e.preventDefault(); dz.classList.remove('active');
      const incoming = dragEl; if(!incoming) return;
      const key = `orders|${p.order}`;
      qsAttempts.set(key, (qsAttempts.get(key)||0)+1);

      if(incoming.dataset.order===p.order && !dz.classList.contains('ok')){
        dz.classList.add('ok'); dz.textContent='';
        incoming.classList.add('locked','small'); dz.appendChild(incoming);
        score+=2; log('Orders', `${p.order}→${p.concept}`, 'match', 'correct');
        toast('✅ Matched!', 'ok');
      }else{
        mistakes++; log('Orders', `${incoming.dataset.order}→${p.concept}`, 'match', 'wrong');
        dz.classList.add('bad'); setTimeout(()=>dz.classList.remove('bad'),250);
        toast('❌ Not that concept. Try a different target.', 'bad');
        snapBack(incoming);
      }
      updateHUD();
    });
    targets.appendChild(dz);
  });
  // Pool (orders)
  shuffle(pairs).forEach((p,i)=>{
    const chip = document.createElement('div');
    chip.className='chip'; chip.textContent=p.order; chip.dataset.order=p.order; chip.dataset.key=`ord-${i}`;
    makeDraggable(chip); pool.appendChild(chip);
  });
  updateHUD();
}

/* ======= EXPORT & PLAY AGAIN ======= */
function exportCSV(){
  // header
  const hdr = ["timestamp","game","item","action","result","attempts","score_end","mistakes_end"];
  const endS = score, endM = mistakes;
  const rows = logRows.map(r=>[r.ts,r.game, csvSafe(r.item), r.action, r.result, r.attempts, endS, endM]);
  const csv = [hdr.join(","), ...rows.map(r=>r.join(","))].join("\n");
  const blob = new Blob([csv], {type:"text/csv;charset=utf-8"});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = `cpc_results_${new Date().toISOString().replace(/[:.]/g,'-')}.csv`;
  document.body.appendChild(a); a.click(); setTimeout(()=>URL.revokeObjectURL(a.href), 1000);
  a.remove();
}
const csvSafe = s => `"${String(s).replaceAll('"','""')}"`;
function resetAll(){
  score=0; mistakes=0; logRows=[]; qsAttempts.clear();
  setupFlow(); setupJuris(); setupOrders();
  showGame("flow"); gameIndex=0;
}

/* ======= NAV / INIT ======= */
function showGame(id){
  games.forEach(g=>{
    byId(g).classList.toggle('hidden', g!==id);
    document.querySelector(`.tab[data-game="${g}"]`).classList.toggle('active', g===id);
  });
  updateHUD();
}
function currentGameId(){ return games[gameIndex]; }

document.querySelectorAll('.tab').forEach(t=>{
  t.addEventListener('click', ()=>{
    gameIndex = games.indexOf(t.dataset.game);
    showGame(t.dataset.game);
  });
});
byId('btnNext').addEventListener('click', ()=>{
  gameIndex = (gameIndex+1)%games.length;
  showGame(games[gameIndex]);
});
byId('btnReset').addEventListener('click', ()=>{
  const id = currentGameId();
  if(id==='flow') setupFlow();
  if(id==='juris') setupJuris();
  if(id==='orders') setupOrders();
  toast('🔄 Current game reshuffled');
});
byId('btnExport').addEventListener('click', exportCSV);
byId('btnPlayAgain').addEventListener('click', ()=>{
  resetAll();
  toast('🎮 New round started. Good luck!');
});
window.addEventListener('keydown', (e)=>{
  if(e.key.toLowerCase()==='r') byId('btnReset').click();
  if(e.key.toLowerCase()==='n') byId('btnNext').click();
});

/* ======= BOOT ======= */
setupFlow(); setupJuris(); setupOrders(); showGame("flow");

/* Small auditory feedback (optional, inline) */
let audioCtx;
function bleep(freq=880, ms=100, type='sine'){
  try{
    audioCtx = audioCtx || new (window.AudioContext||window.webkitAudioContext)();
    const o = audioCtx.createOscillator(), g = audioCtx.createGain();
    o.type=type; o.frequency.value=freq; o.connect(g); g.connect(audioCtx.destination);
    o.start(); g.gain.setValueAtTime(.15, audioCtx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + ms/1000);
    setTimeout(()=>o.stop(), ms);
  }catch{}
}
const _toast = toast;
toast = (msg,tone)=>{ _toast(msg,tone); if(tone==='ok') bleep(990,100,'triangle'); if(tone==='bad') bleep(220,120,'sawtooth'); };
</script>
</body>
</html>